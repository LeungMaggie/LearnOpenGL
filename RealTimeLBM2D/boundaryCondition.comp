#version 430 core

// SSBO
layout (std430, binding = 0) readonly buffer inBuff { float fIn[]; };
layout (std430, binding = 1) writeonly buffer outBuff { float fOut[]; };



// variables
uniform int nx;
uniform int ny;
uniform int strideSoA; // == (nx + 2) * (ny + 2)

uniform int dirNum;
uniform float omega;

const float wt[9] = float[](4.0 / 9.0,
  1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0,
  1.0 / 36.0, 1.0 / 36.0, 1.0 / 36.0, 1.0 / 36.0);

const int ex[9] = int[](0, 1, 0, -1, 0, 1, -1, -1, 1);
const int ey[9] = int[](0, 0, 1, 0, -1, 1, 1, -1, -1);
const int opp[9] = int[](0, 3, 4, 1, 2, 7, 8, 5, 6);

int get_SoA_idx(int iDir, int ptId)
{
  return iDir * strideSoA + ptId;
}

int get_ptId(ivec2 pos)
{
  return (pos.y + 1) * (nx + 2) + (pos.x + 1);
}

void load_local_pdf(inout float fLocal[9], int ptId)
{
  for (int i = 0; i < 9; ++i)
  {
    int idx = get_SoA_idx(i, ptId);
    fLocal[i] = fIn[idx];
  }
}

void point_source()
{

}

// Martin Geier et al., 2015 
void boundary_outflow(ivec2 pos)
{
  int i = 0;
  // x min
  if (pos.x == 0 && !(pos.y == 0 || pos.y == ny))
    i = 1;
  else if (pos.x == nx && !(pos.y == 0 || pos.y == ny))
    i = 3;
  else if (pos.y == 0 && !(pos.x == 0 || pos.x == nx))
    i = 2;
  else if (pos.y == ny && !(pos.x == 0 || pos.x == nx))
    i = 4;
  else
    return;

  float ctheta = 1.0 / sqrt(3.0);
  int ptId = get_ptId(pos);
  int pt1stInnerNbId = get_ptId(ivec2(pos.x + ex[i], pos.y + ey[i]));
  int pt2ndInnerNbId = get_ptId(ivec2(pos.x + ex[i], pos.y + ey[i]));
  int idx = get_SoA_idx(i, ptId);
  int idx1stInnerNb = get_SoA_idx(i, pt1stInnerNbId);
  int idx2ndInnerNb = get_SoA_idx(i, pt2ndInnerNbId);
  fOut[idx] = fIn[idx2ndInnerNb] * ctheta + (1.0 - ctheta) * fIn[idx1stInnerNb];
}

void boundary_farfield()
{
}

void periodic()
{

}

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;
// mask
layout (r8, binding = 2) readonly uniform image2D obstacleMask;
layout (binding = 2, r8ui) readonly uniform uimage2D boundaryMask;
layout (location = 0) readonly uniform float time;

void main()
{
  ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
  if (pos.x >= nx || pos.y >= ny)
  {
    return;
  }
  
  float mask = imageLoad(obstacleMask, pos).r;
  if (mask < 0.5) // fluid
  {
    return;
  }

  // fIn: post-streaming pdf
  for (int i = 0; i < 9; ++i)
  {
    ivec2 posNb = ivec2(pos.x + ex[i], pos.y + ey[i]);
    float maskNb = imageLoad(obstacleMask, posNb).r;
    if (maskNb > 0.5)
    {
      continue;
    }
    int ptId = get_ptId(pos);
    int ptIdNb = get_ptId(posNb);
    int idxNb = get_SoA_idx(i, ptIdNb);
    int idxOpp = get_SoA_idx(opp[i], ptId);
    fOut[idxNb] = fIn[idxOpp];
  }


}
