#version 430 core

// SSBO
layout (std430, binding = 0) readonly buffer inBuff { float fIn[]; };
layout (std430, binding = 1) writeonly buffer outBuff { float fOut[]; };

// mask
layout (r8, binding = 2) readonly uniform image2D obstacleMask;
// layout (binding = 2, r8ui) readonly uniform uimage2D boundaryMask;

// variables
layout (location = 0) readonly uniform int nx;
layout (location = 1) readonly uniform int ny;
layout (location = 2) readonly uniform int strideSoA; // == (nx + 2) * (ny + 2)
layout (location = 3) readonly uniform float omega;
layout (location = 4) readonly uniform float time;

const float wt[9] = float[](4.0 / 9.0,
  1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0,
  1.0 / 36.0, 1.0 / 36.0, 1.0 / 36.0, 1.0 / 36.0);

const int ex[9] = int[](0, 1, 0, -1, 0, 1, -1, -1, 1);
const int ey[9] = int[](0, 0, 1, 0, -1, 1, 1, -1, -1);
const int opp[9] = int[](0, 3, 4, 1, 2, 7, 8, 5, 6);
const ivec3 east = ivec3(1, 5, 8);
const ivec3 south = ivec3(4, 7, 8);
const ivec3 west = ivec3(3, 6, 7);
const ivec3 north = ivec3(2, 5, 6);

int get_SoA_idx(int iDir, int ptId)
{
  return iDir * strideSoA + ptId;
}

int get_ptId(ivec2 pos)
{
  return (pos.y + 1) * (nx + 2) + (pos.x + 1);
}

bool is_valid(ivec2 pos)
{
  return (pos.x >= -1 && pos.x <= nx && pos.y >= -1 && pos.y <= ny);
}

bool is_inner(ivec2 pos)
{
  return (pos.x >= 0 && pos.x < nx && pos.y >= 0 && pos.y < ny);
}

void load_local_pdf(inout float fLocal[9], int ptId)
{
  for (int i = 0; i < 9; ++i)
  {
    int idx = get_SoA_idx(i, ptId);
    fLocal[i] = fIn[idx];
  }
}

void point_source()
{

}

// Martin Geier et al., 2015 
void boundary_outflow(ivec2 pos)
{
  ivec3 iVec = ivec3(0, 0, 0);
  if (pos.x == 0)
    iVec = east;
  else if (pos.x == nx - 1)
    iVec = west;
  else if (pos.y == 0)
    iVec = north;
  else if (pos.y == ny - 1)
    iVec = south;
  else
    return;

  for (int d = 0; d < 3; ++d)
  {
    int i = iVec[d];
    float ctheta = 1.0 / sqrt(3.0);
    int ptId = get_ptId(pos);
    ivec2 pos1stInner = ivec2(pos.x + ex[i], pos.y + ey[i]);
    ivec2 pos2ndInner = ivec2(pos.x + ex[i], pos.y + ey[i]);
    if (!is_valid(pos1stInner) || !is_valid(pos2ndInner))
      continue;
    int pt1stInnerNbId = get_ptId(pos1stInner);
    int pt2ndInnerNbId = get_ptId(pos2ndInner);
    int idx = get_SoA_idx(i, ptId);
    int idx1stInnerNb = get_SoA_idx(i, pt1stInnerNbId);
    int idx2ndInnerNb = get_SoA_idx(i, pt2ndInnerNbId);
    fOut[idx] = fIn[idx2ndInnerNb] * ctheta + (1.0 - ctheta) * fIn[idx1stInnerNb];
  }
}

void boundary_farfield()
{
}

void periodic()
{

}

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

void main()
{
  ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
  if (!is_inner(pos))
  {
    return;
  }

  float mask = imageLoad(obstacleMask, pos).r;
  if (mask < 0.5) // fluid
  {
    return;
  }

  // fIn: post-streaming pdf
  // bounce back
  for (int i = 0; i < 9; ++i)
  {
    ivec2 posNb = ivec2(pos.x + ex[i], pos.y + ey[i]);
    if (!is_valid(posNb))
    {
      continue;
    }
    float maskNb = imageLoad(obstacleMask, posNb).r;
    if (maskNb > 0.5)
    {
      continue;
    }
    int ptId = get_ptId(pos);
    int ptIdNb = get_ptId(posNb);
    int idxNb = get_SoA_idx(i, ptIdNb);
    int idxOpp = get_SoA_idx(opp[i], ptId);
    fOut[idxNb] = fIn[idxOpp];
  }

  boundary_outflow(pos);
}
